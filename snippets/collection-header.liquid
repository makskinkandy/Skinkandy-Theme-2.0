<div class="collection-header-wrapper banner-section page-content">
  <div class="page-width">
    <div class="breadcrumbs-container flex-grid">
      {%- render 'breadcrumbs' -%}
    </div>
    <header class="section-header">
      <h1 class="section-content__heading h1" style="color: {{ block.settings.title_color }}">{{ collection.title | escape }}</h1>

      {%- if collection.description != blank -%}
        <div class="section-content__text rte">
          {{ collection.description }}
        </div>
      {%- endif -%}
    </header>
    {% if block.settings.custom_filter_1 != blank or block.settings.custom_filter_2 != blank or block.settings.custom_filter_3 != blank %}
      <div class="custom-filter__wrapper">
        {% if block.settings.custom_filter_1 != blank %}
          <a class="ss__list__link btn btn--primary" href="{{ block.settings.custom_filter_1 }}">{{ block.settings.custom_filter_1_text }}</a>
        {% endif %}
        {% if block.settings.custom_filter_2 != blank %}
          <a class="ss__list__link btn btn--primary" href="{{ block.settings.custom_filter_2 }}">{{ block.settings.custom_filter_2_text }}</a>
        {% endif %}
        {% if block.settings.custom_filter_3 != blank %}
          <a class="ss__list__link btn btn--primary" href="{{ block.settings.custom_filter_3 }}">{{ block.settings.custom_filter_3_text }}</a>
        {% endif %}
      </div>
    {% endif %}
    {% if block.settings.filter_menu != blank %}
      {% assign filter = linklists[block.settings.filter_menu] %}
      <div class="filter-menu">
        {% if block.settings.filter_title %}
          <p class="filter-title">{{ block.settings.filter_title }}:</p>
        {% endif %}
    
        <!-- Mobile dropdown -->
        <select class="filter-select" onchange="if (this.value) window.location.href=this.value;">
          <option value="">{{ block.settings.filter_title | default: 'Choose an option' }}</option>
          {% for link in filter.links %}
            <option value="{{ link.url }}">{{ link.title }}</option>
          {% endfor %}
        </select>
    
        <!-- Desktop inline links -->
        <div class="filter-inline">
          {% for link in filter.links %}
            <a href="{{ link.url }}">{{ link.title }}</a>
          {% endfor %}
        </div>
      </div>
    {% endif %}
  </div>
</div>
<script>
  (function () {
    const maxWords = 14;

    document.querySelectorAll(".section-content__text").forEach(block => {
      const originalHTML = block.innerHTML;

      // Create a temporary container to walk DOM
      const container = document.createElement("span");
      container.innerHTML = originalHTML;

      let wordCount = 0;
      let reachedLimit = false;

      const shortContainer = document.createElement("span");
      shortContainer.classList.add("cut-content");
      const fullContainer = document.createElement("span");
      fullContainer.style.display = "none";
      fullContainer.classList.add("hidden-content");

      function walkAndSplit(node, shortParent, fullParent) {
        if (reachedLimit) {
          fullParent.appendChild(node.cloneNode(true));
          return;
        }

        if (node.nodeType === Node.TEXT_NODE) {
          const words = node.textContent.trim().split(/\s+/).filter(Boolean);

          if (wordCount + words.length <= maxWords) {
            wordCount += words.length;
            shortParent.appendChild(node.cloneNode(true));
          } else {
            const allowedWords = maxWords - wordCount;
            const shortText = words.slice(0, allowedWords).join(" ");
            const remainingText = words.slice(allowedWords).join(" ");

            if (shortText) {
              shortParent.appendChild(document.createTextNode(shortText + " "));
            }
            if (remainingText) {
              fullParent.appendChild(document.createTextNode(remainingText));
            }

            wordCount = maxWords;
            reachedLimit = true;
          }

        } else if (node.nodeType === Node.ELEMENT_NODE) {
          const shortClone = node.cloneNode(false);
          const fullClone = node.cloneNode(false);

          Array.from(node.childNodes).forEach(child => {
            walkAndSplit(child, shortClone, fullClone);
          });

          if (shortClone.childNodes.length) shortParent.appendChild(shortClone);
          if (fullClone.childNodes.length) fullParent.appendChild(fullClone);
        }
      }

      Array.from(container.childNodes).forEach(child => {
        walkAndSplit(child, shortContainer, fullContainer);
      });

      // If no trimming is needed, skip
      if (!reachedLimit) return;

      // Create dots and toggle
      const dots = document.createElement("span");
      dots.textContent = "... ";
      dots.className = "read-more-dots";

      const toggle = document.createElement("a");
      toggle.href = "#";
      toggle.textContent = "Read more";
      toggle.className = "read-more-toggle";

      toggle.addEventListener("click", function (e) {
        e.preventDefault();
        const isExpanded = block.classList.toggle("expanded");
        fullContainer.style.display = isExpanded ? "inline" : "none";
        dots.style.display = isExpanded ? "none" : "inline";
        toggle.textContent = isExpanded ? "Read less" : "Read more";
      });

      // Replace original content
      block.innerHTML = "";
      block.appendChild(shortContainer);
      shortContainer.appendChild(dots);
      block.appendChild(fullContainer);
      block.appendChild(toggle);
    });
    
  })
  ();
</script>